<html>
   <head>
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
      <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
      <style>
         .bg-gray {
         background-color: lightgray;
         padding: 40px;
         }
         #promptArea,
         #outputArea {
         width: 100%;
         max-width: 100%;
         border-radius: 10px;
         resize: none;
         }
      </style>
   </head>
   <body>
      <div class="container bg-gray">
	  <h2>Interactive ChatGPT</h2>
      <input id="apiKey" type="text" class="form-control" placeholder="Enter your API key here">
      <br>
         <div class="row">
            <div class="col">
               <textarea id="promptArea" rows="5" class="form-control"></textarea>
            </div>
         </div>
		 <div class="row mt-3">     
			<div class="col-3">
               <button id="record" class="btn btn-primary">Record</button>
			   <button id="stop" class="btn btn-primary">Stop</button>
            </div>                
            <div class="col-3 text-right">
               <button id="sendToChatGPT" class="btn btn-primary float-right">Send to ChatGPT</button>
            </div>            
         </div>
		 <hr>
         <div class="row mt-3">
            <div class="col-6">
               <label for="maxTokensSelect">Max Tokens:</label>
               <select id="maxTokensSelect" class="form-control">
                  <option value="10">10</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="200">200</option>
                  <option value="500" selected>500</option>
               </select>
            </div>
            <div class="col-6">
               <label for="temperatureSelect">Temperature:</label>
               <select id="temperatureSelect" class="form-control">
                  <option value="0.5">0.5</option>
                  <option value="1">1</option>
                  <option value="1.5">1.5</option>
                  <option value="2">2</option>
               </select>
            </div>
         </div>
		 <hr>
         <div class="row">
            <div class="col">
               <textarea id="outputArea" rows="5" class="form-control" readonly style="width: 100%; height: auto; overflow: auto;"></textarea>
            </div>
         </div>
         <div class="row mt-3">            
            <div class="col-3">
               <button id="readOut" class="btn btn-primary" onclick="speakOutput()">Read Out</button>
            </div>
         </div>
      </div>
      <script>
         const speakOutput = () => {
             const output = document.getElementById("outputArea").value;
             const utterance = new SpeechSynthesisUtterance();
         
             // Set the text to be spoken
             utterance.text = outputArea.value;
         
             // Set the voice
             utterance.voice = window.speechSynthesis.getVoices().filter(function(voice) {
                 return voice.name == 'Google UK English Male';
             })[0];
         
             // Speak the text
             //window.speechSynthesis.speak(utterance);
         
             speechUtteranceChunker(utterance, {
                 chunkLength: 120
             }, function() {
                 //some code to execute when done
                 //console.log('done');
             });
         
         
         };
         
         
         const recordButton = document.getElementById("record");
         const stopButton = document.getElementById("stop");
         const sendToChatGPTButton = document.getElementById("sendToChatGPT");
         const promptArea = document.getElementById("promptArea");
         const outputArea = document.getElementById("outputArea");
         const apikey = document.getElementById("apiKey");
                  
         let audioStream;
		 
		 let recognizer;
         
         recordButton.addEventListener("click", function() {
             if (recognizer) {
                 return;
             }
             try {
                 audioStream = new webkitAudioContext();
             } catch (e) {
                 //console.error(e);
             }
             recognizer = new webkitSpeechRecognition();
             recognizer.continuous = true;
             recognizer.interimResults = true;
             recognizer.onstart = function() {
                 //console.log("Recording started");
             };
             recognizer.onend = function() {
                 //console.log("Recording stopped");
                 recognizer = null;
             };
             recognizer.onresult = function(event) {
                 for (let i = event.resultIndex; i < event.results.length; i++) {
                     if (event.results[i].isFinal) {
                         promptArea.value += event.results[i][0].transcript;
						 
						let transcript = event.results[i][0].transcript;
						if (transcript.includes("go")) {
							recognizer.stop();
							//console.log("Stopped keyword");
							promptArea.value = promptArea.value.replace("go", "");
							sendToChatGPTButton.click();
							return;
						}
                     }
                 }
             };
             recognizer.start();
         });
		 
		 
		 


         
         stopButton.addEventListener("click", function() {
             if (recognizer) {
                 recognizer.stop();
             }
         });
         
         sendToChatGPTButton.addEventListener("click", function() {
         
             const maxTokens = parseInt(document.getElementById("maxTokensSelect").value);
             const temperature = parseFloat(document.getElementById("temperatureSelect").value);
         
             if (!promptArea.value) {
                 return;
             }
         
             const API_KEY = apikey.value;
             const URL = "https://api.openai.com/v1/engines/text-davinci-003/completions";
         
             // Define the request body with the prompt
             const data = {
                 prompt: document.getElementById("promptArea").value,
                 max_tokens: maxTokens,
                 temperature: temperature,
             };
         
             // Make the API request to the OpenAI API
             fetch(URL, {
                     method: "POST",
                     headers: {
                         "Content-Type": "application/json",
                         "Authorization": `Bearer ${API_KEY}`
                     },
                     body: JSON.stringify(data),
                 })
                 .then((response) => response.json())
                 .then((data) => {
                     //console.log(data);
                     // Extract the generated response from the response
                     const response = data.choices[0].text;
                     // Update the output area with the generated response
                     document.getElementById("outputArea").value = response;
                     document.getElementById("outputArea").style.height = "auto";
                     document.getElementById("outputArea").style.height = document.getElementById("outputArea").scrollHeight + "px";
                 })
                 .catch((error) => {
                     console.error(error);
                 });
         });
         
         
         
         
         var speechUtteranceChunker = function(utt, settings, callback) {
             settings = settings || {};
             var newUtt;
             var txt = (settings && settings.offset !== undefined ? utt.text.substring(settings.offset) : utt.text);
             if (utt.voice && utt.voice.voiceURI === 'native') { // Not part of the spec
                 newUtt = utt;
                 newUtt.text = txt;
                 newUtt.addEventListener('end', function() {
                     if (speechUtteranceChunker.cancel) {
                         speechUtteranceChunker.cancel = false;
                     }
                     if (callback !== undefined) {
                         callback();
                     }
                 });
             } else {
                 var chunkLength = (settings && settings.chunkLength) || 160;
                 var pattRegex = new RegExp('^[\\s\\S]{' + Math.floor(chunkLength / 2) + ',' + chunkLength + '}[.!?,]{1}|^[\\s\\S]{1,' + chunkLength + '}$|^[\\s\\S]{1,' + chunkLength + '} ');
                 var chunkArr = txt.match(pattRegex);
         
                 if (chunkArr[0] === undefined || chunkArr[0].length <= 2) {
                     //call once all text has been spoken...
                     if (callback !== undefined) {
                         callback();
                     }
                     return;
                 }
                 var chunk = chunkArr[0];
                 newUtt = new SpeechSynthesisUtterance(chunk);
                 var x;
                 for (x in utt) {
                     if (utt.hasOwnProperty(x) && x !== 'text') {
                         newUtt[x] = utt[x];
                     }
                 }
                 newUtt.addEventListener('end', function() {
                     if (speechUtteranceChunker.cancel) {
                         speechUtteranceChunker.cancel = false;
                         return;
                     }
                     settings.offset = settings.offset || 0;
                     settings.offset += chunk.length - 1;
                     speechUtteranceChunker(utt, settings, callback);
                 });
             }
         
             if (settings.modifier) {
                 settings.modifier(newUtt);
             }
             console.log(newUtt); //IMPORTANT!! Do not remove: Logging the object out fixes some onend firing issues.
             //placing the speak invocation inside a callback fixes ordering and onend issues.
             setTimeout(function() {
                 speechSynthesis.speak(newUtt);
             }, 0);
         };
         
         
             
      </script>
   </body>
</html>